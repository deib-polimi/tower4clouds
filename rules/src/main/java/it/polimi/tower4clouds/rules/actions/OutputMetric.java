/**
 * Copyright (C) 2014 Politecnico di Milano (marco.miglierina@polimi.it)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package it.polimi.tower4clouds.rules.actions;

import it.polimi.modaclouds.qos_models.EnumErrorType;
import it.polimi.modaclouds.qos_models.Problem;
import it.polimi.tower4clouds.rules.AbstractAction;
import it.polimi.tower4clouds.rules.Action;
import it.polimi.tower4clouds.rules.MonitoringRule;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class OutputMetric extends AbstractAction {

	public static final String metric = "metric";
	public static final String resourceId = "resourceId";
	public static final String value = "value";

	private final Set<String> requiredParameters = new HashSet<String>();
	private final Map<String, String> defaultParameterValues = new HashMap<String, String>();

	public OutputMetric() {
		requiredParameters.add(metric);
		defaultParameterValues.put(resourceId, "ID");
		defaultParameterValues.put(value, "METRIC");
	}

	@Override
	protected Set<String> getMyRequiredPars() {
		return requiredParameters;
	}

	@Override
	protected Map<String, String> getMyDefaultParameterValues() {
		return defaultParameterValues;
	}

	@Override
	protected Set<Problem> validate(MonitoringRule rule,
			List<MonitoringRule> otherRules) {
		Set<Problem> problems = new HashSet<Problem>();
		List<String> metrics = getOutputMetrics(rule);
		if (!findDuplicates(metrics).isEmpty()) {
			problems.add(new Problem(rule.getId(),
					EnumErrorType.INVALID_ACTION, getName(),
					"Metrics name can only be used once"));
		}
		if (otherRules != null) {
			for (MonitoringRule otherRule : otherRules) {
				for (String metric : metrics) {
					if (getOutputMetrics(otherRule).contains(metric)) {
						problems.add(new Problem(rule.getId(),
								EnumErrorType.INVALID_ACTION, getName(),
								"Metric " + metric
										+ " is already generated by rule "
										+ otherRule.getId()));
					}
				}
			}
		}
		return problems;
	}

	private List<String> getOutputMetrics(MonitoringRule rule) {
		List<String> metrics = new ArrayList<String>();
		Set<Action> actions = getMyActions(rule);
		for (Action action : actions) {
			metrics.add(extractParameters(action).get(metric));
		}
		return metrics;
	}

	private static Set<String> findDuplicates(List<String> list) {

		final Set<String> duplicates = new HashSet<String>();
		final Set<String> set1 = new HashSet<String>();

		for (String yourInt : list) {
			if (!set1.add(yourInt)) {
				duplicates.add(yourInt);
			}
		}
		return duplicates;
	}

	@Override
	public void execute(String resourceId, String value, String timestamp) {
		// Nothing to do. This is a special action, nothing is sent to the
		// manager, the metric is just made available at the data analyzer
		// endpoint. When attaching observers to metrics, metrics are sent
		// directly to the observer by the data analyzer.
	}

}